#### Task 1
Реализовал инвертированную версию алгоритма, описанную в задании для простоты
#### Task 2
Реализовал итеративный алгоритм подсчёта максимальной глубины со сложностью O(n)
#### Task 3
Реализовал буфер через очередь на связном списке из прошлой лабы,
вычисляю время выполнения предыдущих запросов в момент получения нового.
Для расчёта последнего/их запроса/ов используется сервисный вопрос,
который гарантированно позволит вызвать код отвечающий за обработку запросов
#### Task 4
На каждый элемент массива возможно максимум log(m) вызовов метода swap, 
где log(m) глубина поддерева с корневым узлом в текущем элементе.
Сложным доказательством доказывается что по итогу это имеет сложность O(n)